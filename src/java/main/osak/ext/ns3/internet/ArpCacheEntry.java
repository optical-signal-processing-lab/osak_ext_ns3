/*
 * Copyright 2024 OSPLAB (Optical Signal Processing Lab Of UESTC)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
package osak.ext.ns3.internet;

import java.util.ArrayList;
import java.util.List;

import osak.ext.ns3.core.Pair;
import osak.ext.ns3.core.Time;
import osak.ext.ns3.network.Address;
import osak.ext.ns3.network.Packet;
import osak.ext.ns3.network.utils.Ipv4Address;
/**
 * TODO ArpCacheEntry
 * 
 * @author zhangrui
 * @since   1.0
 */
public final class ArpCacheEntry {
    private enum ArpCacheEntryState_e {
	ALIVE, WAIT_REPLY, DEAD, PERMANENT, STATIC_AUTOGENERATED
    }

    /**
     * @brief Returns the entry timeout
     * @returns the entry timeout
     */
    private Time GetTimeout() {
	switch (m_state) {
	case WAIT_REPLY:
	    return m_arp.GetWaitReplyTimeout();
	case DEAD:
	    return m_arp.GetDeadTimeout();
	case ALIVE:
	    return m_arp.GetAliveTimeout();
	case PERMANENT:
	    return Time.Max();
	case STATIC_AUTOGENERATED:
	    return Time.Max();
	}
	return new Time();
    }

    private ArpCache m_arp; // !< pointer to the ARP cache owning the entry

    private ArpCacheEntryState_e m_state; // !< state of the entry
    private long m_lastSeen; // !< last moment a packet from that address has been seen
    private Address m_macAddress; // !< entry's MAC address
    private Ipv4Address m_ipv4Address; // !< entry's IP address
    private List<Pair<Packet, Ipv4Header>> m_pending = new ArrayList<>(); // !< list of pending packets for the entry's
									  // IP
    private int m_retries;

    /**
     * Constructor
     * 
     * @param arp The ArpCache this entry belongs to
     */
    public ArpCacheEntry(ArpCache arp) {
	m_arp = arp;
	m_state = ArpCacheEntryState_e.ALIVE;
	m_retries = 0;
    }

    /**
     * Changes the state of this entry to dead
     */
    public void MarkDead() {
	m_state = ArpCacheEntryState_e.DEAD;
	ClearRetries();
	UpdateSeen();
    }

    /**
     * @param macAddress
     */
    public void MarkAlive(Address macAddress) {
	m_macAddress = macAddress;
	m_state = ArpCacheEntryState_e.ALIVE;
	ClearRetries();
	UpdateSeen();
    }

    /**
     * @param waiting
     */
    public void MarkWaitReply(Pair<Packet, Ipv4Header> waiting) {
	m_state = ArpCacheEntryState_e.WAIT_REPLY;
	m_pending.add(waiting);
	UpdateSeen();
	m_arp.StartWaitReplyTimer();
    }

    /**
     * Changes the state of this entry to Permanent.
     *
     * The entry must have a valid MacAddress.
     */
    public void MarkPermanent() {
	m_state = ArpCacheEntryState_e.PERMANENT;
	ClearRetries();
	UpdateSeen();
    }

    /**
     * Changes the state of this entry to auto-generated.
     *
     * The entry must have a valid MacAddress.
     */
    public void MarkAutoGenerated() {
	m_state = ArpCacheEntryState_e.STATIC_AUTOGENERATED;
	ClearRetries();
	UpdateSeen();
    }

    /**
     * @param waiting
     * @return
     */
    public boolean UpdateWaitReply(Pair<Packet, Ipv4Header> waiting) {
	if (m_pending.size() >= m_arp.m_pendingQueueSize) {
	    return false;
	}
	m_pending.add(waiting);
	return true;
    }

    /**
     * @return True if the state of this entry is dead; false otherwise.
     */
    public boolean IsDead() {
	return m_state == ArpCacheEntryState_e.DEAD;
    }

    /**
     * @return True if the state of this entry is alive; false otherwise.
     */
    public boolean IsAlive() {
	return m_state == ArpCacheEntryState_e.ALIVE;
    }

    /**
     * @return True if the state of this entry is wait_reply; false otherwise.
     */
    public boolean IsWaitReply() {
	return m_state == ArpCacheEntryState_e.WAIT_REPLY;
    }

    /**
     * @return True if the state of this entry is permanent; false otherwise.
     */
    public boolean IsPermanent() {
	return m_state == ArpCacheEntryState_e.PERMANENT;
    }

    /**
     * @return True if the state of this entry is auto-generated; false otherwise.
     */
    public boolean IsAutoGenerated() {
	return m_state == ArpCacheEntryState_e.STATIC_AUTOGENERATED;
    }

    /**
     * @return The MacAddress of this entry
     */
    public Address GetMacAddress() {
	return m_macAddress;
    }

    /**
     * @return The Ipv4Address for this entry
     */
    public Ipv4Address GetIpv4Address() {
	return m_ipv4Address;
    }

    /**
     * @param macAddress The MacAddress for this entry
     */
    public void SetMacAddress(Address macAddress) {
	m_macAddress = macAddress;
    }

    /**
     * @param destination The Ipv4Address for this entry
     */
    public void SetIpv4Address(Ipv4Address destination) {
	m_ipv4Address = destination;
    }

    /**
     * @return True if this entry has timed out; false otherwise.
     *
     *         This function returns true if the time elapsed strictly exceeds the
     *         timeout value (i.e., is not less than or equal to the timeout).
     */
    public boolean IsExpired() {
	long timeout = GetTimeout().getMillSeconds();
	long delta = System.currentTimeMillis() - m_lastSeen;
	if (delta > timeout) {
	    return true;
	}
	return false;
    }

    /**
     * @returns 0 is no packet is pending, the next packet to send if packets are
     *          pending.
     */
    public Pair<Packet, Ipv4Header> DequeuePending() {
	if (m_pending.isEmpty()) {
	    Ipv4Header h = new Ipv4Header();
	    return new Pair<Packet, Ipv4Header>(null, h);
	}
	else {
	    Pair<Packet, Ipv4Header> p = m_pending.get(0);
	    m_pending.remove(0);
	    return p;
	}
    }

    /**
     * Clear the pending packet list
     */
    public void ClearPendingPacket() {
	m_pending.clear();
    }

    /**
     * @returns number of retries that have been sent for an ArpRequest in WaitReply
     *          state.
     */
    public int GetRetries() {
	return m_retries;
    }

    /**
     * Increment the counter of number of retries for an entry
     */
    public void IncrementRetries() {
	m_retries++;
	UpdateSeen();
    }

    /**
     * Zero the counter of number of retries for an entry
     */
    public void ClearRetries() {
	m_retries = 0;
    }

    /**
     * Update the entry when seeing a packet
     */
    public void UpdateSeen() {
	m_lastSeen = System.currentTimeMillis();
    }
}
